[{"title":"两个线程交替打印字符","date":"2019-11-20T06:14:43.000Z","path":"2019/11/20/两个线程交替打印字符/","text":"题目：多线程交替打印1A2B3C……26Z 定义统一变量 123456private static ExecutorService executorService = Executors.newSingleThreadExecutor();private static ReentrantLock reentrantLock = new ReentrantLock();private static volatile AtomicInteger ReadyToRun = new AtomicInteger(0);private static volatile int data = 1;private static Object object = new Object();private static volatile boolean flag = true; 方法一 1234567891011121314151617181920212223242526272829303132333435363738394041424344public static void printABC3() &#123; new Thread(new Runnable() &#123; @Override public void run() &#123; while (true) &#123; if (data &gt; 26) &#123; ReadyToRun.set(1); System.out.println(Thread.currentThread().getName() + \": stop\"); break; &#125; while (ReadyToRun.get() == 0) &#123; if (data &gt; 26)&#123; ReadyToRun.set(1); break; &#125; System.out.println(Thread.currentThread().getName() + \": \"+ data); ReadyToRun.set(1); &#125; &#125; &#125; &#125;,\"t1\").start(); new Thread(new Runnable() &#123; @Override public void run() &#123; while (true) &#123; if (data &gt;= 27)&#123; break; &#125; while (ReadyToRun.get() == 1) &#123; System.out.println(Thread.currentThread().getName() + \" : \" + (char) (data + 64)); data++; if (data &gt; 26) &#123; System.out.println(Thread.currentThread().getName() + \": stop\"); break; &#125; ReadyToRun.set(0); &#125; &#125; &#125; &#125;,\"t2\").start(); &#125; 3.方法二： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/** * wait方法是object中的方法。调用wait方法之后，会立即释放锁，该线程放到等待池中，到有notify()或者notifyAll()调用的时候，会将该线程 * 从等待池放到锁池中，锁池的中线程竞争该锁。notify()方法不会释放锁,必须等待notfiy()所在的synchronized块执行结束才会结束 */ public static void printABC2() &#123; new Thread(new Runnable() &#123; @Override public void run() &#123; while (true) &#123; synchronized (object) &#123; if (data &gt; 26) &#123; System.out.println(Thread.currentThread().getName() + \" stop\" ); // 这里加入object.notify()让线程2正常退出 object.notify(); break; &#125; if (flag) &#123; System.out.print(data); flag = false; try &#123; object.notify(); object.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; &#125; &#125;,\"t1\").start(); new Thread(new Runnable() &#123; @Override public void run() &#123; while (true) &#123; if (data &gt; 26) &#123; System.out.println(Thread.currentThread().getName() + \" stop\" ); break; &#125; synchronized (object) &#123; if (!flag) &#123; System.out.print((char) (data + 64)); data++; flag = true; try &#123; object.notify(); object.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; &#125; &#125;,\"t2\").start(); &#125; 3: 123456789101112131415161718192021222324252627282930313233343536373839public static void printABC1() &#123; new Thread(new Runnable() &#123; @Override public void run() &#123; while (true) &#123; reentrantLock.lock(); if (data &gt; 26) &#123; reentrantLock.unlock(); break; &#125; if (flag) &#123; System.out.print(data); flag = false; &#125; reentrantLock.unlock(); &#125; &#125; &#125;, \"thread-num\").start(); new Thread(new Runnable() &#123; @Override public void run() &#123; while (true) &#123; reentrantLock.lock(); if (data &gt; 26) &#123; // 注意解锁 reentrantLock.unlock(); break; &#125; if (!flag) &#123; System.out.print((char) (data + 64)); flag = true; data++; &#125; reentrantLock.unlock(); &#125; &#125; &#125;, \"thread-char\").start(); &#125; newSingleThreadExecutor方法是保证提交的任务顺序执行 12345678910111213141516public static void printABC() &#123; int[] data = new int[26]; for (int i = 0; i &lt; 26; i++) &#123; data[i] = i + 1; &#125; for (int i = 0; i &lt; 26; i++) &#123; int temp = data[i]; executorService.submit(new Runnable() &#123; @Override public void run() &#123; System.out.print(temp + \"\" + (char) (temp + 64)); &#125; &#125;); &#125; &#125;","tags":[{"name":"面试","slug":"面试","permalink":"http://byejd.github.io/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"leetcode-200.岛屿数量","date":"2019-11-20T04:55:59.000Z","path":"2019/11/20/leetcode-200.岛屿数量/","text":"本质上就是求图的连通分量的个数。利用栈实现图的遍历。没有使用图的递归 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071import java.util.Scanner;import java.util.Stack;public class Main &#123; static class Node &#123; int x; int y; int value; public Node(int x, int y, int value) &#123; this.x = x; this.y = y; this.value = value; &#125; &#125; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); int m = sc.nextInt(); int n = sc.nextInt(); int[][] map = new int[m][n]; int[][] visited = new int[m][n]; for (int i = 0; i &lt; m; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; map[i][j] = sc.nextInt(); visited[i][j] = 0; &#125; &#125; int count = 0; for (int i = 0; i &lt; m; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; if (visited[i][j] != 1 &amp;&amp; map[i][j] == 1) &#123; count++; visited[i][j] = 1; Node beginNode = new Node(i, j, map[i][j]); Stack&lt;Node&gt; stack = new Stack&lt;&gt;(); stack.push(beginNode); while (!stack.isEmpty()) &#123; Node node = stack.peek(); // 下 if (node.x + 1 &lt; m &amp;&amp; map[node.x + 1][node.y] == 1 &amp;&amp; visited[node.x + 1][node.y] == 0) &#123; visited[node.x + 1][node.y] = 1; Node node1 = new Node(node.x + 1, node.y, 1); stack.push(node1); // 右 &#125; else if (node.y + 1 &lt; n &amp;&amp; map[node.x][node.y + 1] == 1 &amp;&amp; visited[node.x][node.y + 1] == 0) &#123; visited[node.x][node.y + 1] = 1; Node node1 = new Node(node.x, node.y + 1, 1); stack.push(node1); // 上 &#125; else if (node.x - 1 &gt;= 0 &amp;&amp; map[node.x - 1][node.y] == 1 &amp;&amp; visited[node.x - 1][node.y] == 0) &#123; visited[node.x - 1][node.y] = 1; Node node1 = new Node(node.x - 1, node.y, 1); stack.push(node1); // 左 &#125; else if (node.y - 1 &gt;= 0 &amp;&amp; map[node.x][node.y - 1] == 1 &amp;&amp; visited[node.x][node.y - 1] == 0) &#123; visited[node.x][node.y - 1] = 1; Node node1 = new Node(node.x, node.y - 1, 1); stack.push(node1); &#125; else &#123; stack.pop(); &#125; &#125; &#125; &#125; &#125; System.out.println(count); &#125;&#125;","tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://byejd.github.io/tags/leetcode/"},{"name":"面试","slug":"面试","permalink":"http://byejd.github.io/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"Hello World","date":"2019-11-17T10:40:14.237Z","path":"2019/11/17/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]}]