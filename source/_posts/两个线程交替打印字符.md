---
title: 两个线程交替打印字符
date: 2019-11-20 14:14:43
tags: 面试
---

 题目：多线程交替打印1A2B3C......26Z<!-- more --> 

1. 定义统一变量

```java
private static ExecutorService executorService = Executors.newSingleThreadExecutor();
private static ReentrantLock reentrantLock = new ReentrantLock();
private static volatile AtomicInteger ReadyToRun = new AtomicInteger(0);
private static volatile int data = 1;
private static Object object = new Object();
private static volatile boolean flag = true;
```

2. 方法一

```java
public static void printABC3() {
        new Thread(new Runnable() {
            @Override
            public void run() {
                while (true) {
                    if (data > 26) {
                        ReadyToRun.set(1);
                        System.out.println(Thread.currentThread().getName() + ": stop");
                        break;
                    }
                    while (ReadyToRun.get() == 0) {
                        if (data > 26){
                            ReadyToRun.set(1);
                            break;
                        }
                        System.out.println(Thread.currentThread().getName() + ":  "+  data);
                        ReadyToRun.set(1);
                    }

                }
            }
        },"t1").start();

        new Thread(new Runnable() {
            @Override
            public void run() {
                while (true) {
                    if (data >= 27){
                        break;
                    }
                    while (ReadyToRun.get() == 1) {
                        System.out.println(Thread.currentThread().getName()  + " : " + (char) (data + 64));
                        data++;
                        if (data > 26) {
                            System.out.println(Thread.currentThread().getName() + ": stop");
                            break;
                        }
                        ReadyToRun.set(0);
                    }
                }
            }
        },"t2").start();

    }

```

   3.方法二：

```java
 /**
     * wait方法是object中的方法。调用wait方法之后，会立即释放锁，该线程放到等待池中，到有notify()或者notifyAll()调用的时候，会将该线程
     * 从等待池放到锁池中，锁池的中线程竞争该锁。notify()方法不会释放锁,必须等待notfiy()所在的synchronized块执行结束才会结束
     */
    public static void printABC2() {
        new Thread(new Runnable() {
            @Override
            public void run() {
                while (true) {
                    synchronized (object) {
                        if (data > 26) {
                            System.out.println(Thread.currentThread().getName() + " stop" );
                            // 这里加入object.notify()让线程2正常退出
                            object.notify();
                            break;
                        }

                        if (flag) {
                            System.out.print(data);
                            flag = false;
                            try {
                                object.notify();
                                object.wait();
                            } catch (InterruptedException e) {
                                e.printStackTrace();
                            }
                        }
                    }
                }
            }
        },"t1").start();

        new Thread(new Runnable() {
            @Override
            public void run() {
                while (true) {
                    if (data > 26) {
                        System.out.println(Thread.currentThread().getName() + " stop" );
                        break;
                    }
                    synchronized (object) {
                        if (!flag) {
                            System.out.print((char) (data + 64));
                            data++;
                            flag = true;
                            try {
                                object.notify();
                                object.wait();
                            } catch (InterruptedException e) {
                                e.printStackTrace();
                            }
                        }
                    }
                }
            }
        },"t2").start();
    }
```



3:

```java
public static void printABC1() {
        new Thread(new Runnable() {
            @Override
            public void run() {
                while (true) {
                    reentrantLock.lock();
                    if (data > 26) {
                        reentrantLock.unlock();
                        break;
                    }
                    if (flag) {
                        System.out.print(data);
                        flag = false;
                    }
                    reentrantLock.unlock();
                }
            }
        }, "thread-num").start();

        new Thread(new Runnable() {
            @Override
            public void run() {
                while (true) {
                    reentrantLock.lock();
                    if (data > 26) {
                        // 注意解锁
                        reentrantLock.unlock();
                        break;
                    }
                    if (!flag) {
                        System.out.print((char) (data + 64));
                        flag = true;
                        data++;
                    }
                    reentrantLock.unlock();
                }
            }
        }, "thread-char").start();
    }
```

4. newSingleThreadExecutor方法是保证提交的任务顺序执行

```java
public static void printABC() {
        int[] data = new int[26];
        for (int i = 0; i < 26; i++) {
            data[i] = i + 1;
        }

        for (int i = 0; i < 26; i++) {
            int temp = data[i];
            executorService.submit(new Runnable() {
                @Override
                public void run() {
                    System.out.print(temp + "" + (char) (temp + 64));
                }
            });
        }
    }

```

